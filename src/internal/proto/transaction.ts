//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//
//       bebopc version:
//           3.1.3
//
//
//       bebopc source:
//           https://github.com/betwixt-labs/bebop
//
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
import { BebopView, BebopRuntimeError, BebopRecord, BebopJson, BebopTypeGuard, Guid, GuidMap } from "bebop";

export const BEBOP_SCHEMA = new Uint8Array ([
3, 7, 0, 0, 0, 83, 116, 97, 116, 117, 115, 0, 4, 0, 251,
255, 255, 255, 0, 4, 0, 0, 0, 4, 68, 69, 84, 65, 85, 76,
84, 0, 0, 0, 0, 0, 0, 67, 79, 77, 77, 73, 84, 84, 69, 68,
0, 0, 1, 0, 0, 0, 65, 66, 79, 82, 84, 69, 68, 0, 0, 2, 0,
0, 0, 80, 69, 78, 68, 73, 78, 71, 0, 0, 3, 0, 0, 0, 84,
114, 97, 110, 115, 97, 99, 116, 105, 111, 110, 76, 111,
103, 0, 1, 0, 0, 16, 0, 0, 0, 0, 3, 116, 105, 109, 101,
115, 116, 97, 109, 112, 0, 243, 255, 255, 255, 0, 115,
116, 97, 116, 117, 115, 0, 0, 0, 0, 0, 0, 119, 114, 105,
116, 101, 115, 0, 242, 255, 255, 255, 0, 2, 0, 0, 0, 0,
67, 111, 108, 108, 101, 99, 116, 105, 111, 110, 87, 114,
105, 116, 101, 115, 0, 1, 0, 0, 16, 0, 0, 0, 0, 3, 112,
114, 101, 102, 105, 120, 0, 245, 255, 255, 255, 0, 119,
114, 105, 116, 101, 115, 0, 242, 255, 255, 255, 0, 3, 0,
0, 0, 0, 108, 111, 99, 107, 115, 0, 5, 0, 0, 0, 0, 87,
114, 105, 116, 101, 0, 2, 0, 5, 0, 0, 0, 4, 115, 117, 102,
102, 105, 120, 0, 245, 255, 255, 255, 0, 1, 112, 114, 101,
118, 95, 116, 105, 100, 0, 242, 255, 255, 255, 0, 254,
255, 255, 255, 0, 2, 118, 97, 108, 117, 101, 0, 242, 255,
255, 255, 0, 254, 255, 255, 255, 0, 3, 100, 101, 108, 101,
116, 101, 100, 0, 255, 255, 255, 255, 0, 4, 76, 111, 99,
107, 84, 121, 112, 101, 0, 4, 0, 251, 255, 255, 255, 0, 4,
0, 0, 0, 5, 85, 78, 75, 78, 79, 87, 78, 0, 0, 0, 0, 0, 0,
78, 79, 78, 69, 0, 0, 1, 0, 0, 0, 82, 69, 65, 68, 0, 0, 2,
0, 0, 0, 87, 82, 73, 84, 69, 0, 0, 3, 0, 0, 0, 67, 82, 69,
65, 84, 69, 0, 0, 4, 0, 0, 0, 67, 111, 108, 108, 101, 99,
116, 105, 111, 110, 76, 111, 99, 107, 115, 0, 1, 0, 0, 8,
0, 0, 0, 0, 2, 99, 111, 108, 108, 101, 99, 116, 105, 111,
110, 95, 108, 111, 99, 107, 0, 4, 0, 0, 0, 0, 108, 111,
99, 107, 115, 0, 242, 255, 255, 255, 0, 6, 0, 0, 0, 0, 76,
111, 99, 107, 0, 1, 0, 0, 8, 0, 0, 0, 0, 2, 115, 117, 102,
102, 105, 120, 0, 245, 255, 255, 255, 0, 108, 111, 99,
107, 95, 116, 121, 112, 101, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0
]);

export enum Status {

  Detault = 0,

  Committed = 1,

  Aborted = 2,

  Pending = 3,
}


export interface ITransactionLog extends BebopRecord {

  readonly timestamp: Date;

  readonly status: Status;

  readonly writes: Array<ICollectionWrites>;
}

export class TransactionLog implements ITransactionLog {
  public readonly timestamp: Date;
  public readonly status: Status;
  public readonly writes: Array<ICollectionWrites>;

  constructor(record: ITransactionLog) {
    this.timestamp = record.timestamp;
    this.status = record.status;
    this.writes = record.writes;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return TransactionLog.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: ITransactionLog): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    TransactionLog.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link TransactionLog}.
   */
  public static validateCompatibility(record: ITransactionLog): void {
    BebopTypeGuard.ensureDate(record.timestamp)
    BebopTypeGuard.ensureEnum(record.status, Status);
    BebopTypeGuard.ensureArray(record.writes, CollectionWrites.validateCompatibility);
  }

  /**
   * Unsafely creates an instance of {@link TransactionLog} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): ITransactionLog {
      return new TransactionLog(record);
  }

  /**
   * Creates a new {@link TransactionLog} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): ITransactionLog {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`TransactionLog.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    TransactionLog.validateCompatibility(parsed);
    return TransactionLog.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return TransactionLog.encode(this);
  }

  public static encode(record: ITransactionLog): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    TransactionLog.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: ITransactionLog, view: BebopView): number {
    const before = view.length;
    view.writeDate(record.timestamp);
    view.writeUint32(record.status);
    {
      const length0 = record.writes.length;
      view.writeUint32(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        CollectionWrites.encodeInto(record.writes[i0], view)
      }
    }
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): ITransactionLog {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return TransactionLog.readFrom(view);
  }

  public static readFrom(view: BebopView): ITransactionLog {
    let field0: Date;
    field0 = view.readDate();
    let field1: Status;
    field1 = view.readUint32() as Status;
    let field2: Array<ICollectionWrites>;
    {
      let length0 = view.readUint32();
      field2 = new Array<ICollectionWrites>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: ICollectionWrites;
        x0 = CollectionWrites.readFrom(view);
        field2[i0] = x0;
      }
    }
    let message: ITransactionLog = {
      timestamp: field0,
      status: field1,
      writes: field2,
    };
    return new TransactionLog(message);
  }
}


export interface ICollectionWrites extends BebopRecord {

  readonly prefix: string;

  readonly writes: Array<IWrite>;

  readonly locks: ICollectionLocks;
}

export class CollectionWrites implements ICollectionWrites {
  public readonly prefix: string;
  public readonly writes: Array<IWrite>;
  public readonly locks: ICollectionLocks;

  constructor(record: ICollectionWrites) {
    this.prefix = record.prefix;
    this.writes = record.writes;
    this.locks = record.locks;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return CollectionWrites.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: ICollectionWrites): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    CollectionWrites.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link CollectionWrites}.
   */
  public static validateCompatibility(record: ICollectionWrites): void {
    BebopTypeGuard.ensureString(record.prefix)
    BebopTypeGuard.ensureArray(record.writes, Write.validateCompatibility);
    CollectionLocks.validateCompatibility(record.locks);
  }

  /**
   * Unsafely creates an instance of {@link CollectionWrites} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): ICollectionWrites {
      record.locks = CollectionLocks.unsafeCast(record.locks);
      return new CollectionWrites(record);
  }

  /**
   * Creates a new {@link CollectionWrites} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): ICollectionWrites {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`CollectionWrites.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    CollectionWrites.validateCompatibility(parsed);
    return CollectionWrites.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return CollectionWrites.encode(this);
  }

  public static encode(record: ICollectionWrites): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    CollectionWrites.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: ICollectionWrites, view: BebopView): number {
    const before = view.length;
    view.writeString(record.prefix);
    {
      const length0 = record.writes.length;
      view.writeUint32(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        Write.encodeInto(record.writes[i0], view)
      }
    }
    CollectionLocks.encodeInto(record.locks, view)
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): ICollectionWrites {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return CollectionWrites.readFrom(view);
  }

  public static readFrom(view: BebopView): ICollectionWrites {
    let field0: string;
    field0 = view.readString();
    let field1: Array<IWrite>;
    {
      let length0 = view.readUint32();
      field1 = new Array<IWrite>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: IWrite;
        x0 = Write.readFrom(view);
        field1[i0] = x0;
      }
    }
    let field2: ICollectionLocks;
    field2 = CollectionLocks.readFrom(view);
    let message: ICollectionWrites = {
      prefix: field0,
      writes: field1,
      locks: field2,
    };
    return new CollectionWrites(message);
  }
}


export interface IWrite extends BebopRecord {

  suffix?: string;

  prevTid?: Uint8Array;

  value?: Uint8Array;

  deleted?: boolean;
}

export class Write implements IWrite {
  public suffix?: string;
  public prevTid?: Uint8Array;
  public value?: Uint8Array;
  public deleted?: boolean;

  constructor(record: IWrite) {
    this.suffix = record.suffix;
    this.prevTid = record.prevTid;
    this.value = record.value;
    this.deleted = record.deleted;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return Write.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IWrite): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    Write.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link Write}.
   */
  public static validateCompatibility(record: IWrite): void {
    if (record.suffix !== undefined) {
      BebopTypeGuard.ensureString(record.suffix)
    }
    if (record.prevTid !== undefined) {
      BebopTypeGuard.ensureArray(record.prevTid, BebopTypeGuard.ensureUint8);
    }
    if (record.value !== undefined) {
      BebopTypeGuard.ensureArray(record.value, BebopTypeGuard.ensureUint8);
    }
    if (record.deleted !== undefined) {
      BebopTypeGuard.ensureBoolean(record.deleted)
    }
  }

  /**
   * Unsafely creates an instance of {@link Write} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IWrite {
      return new Write(record);
  }

  /**
   * Creates a new {@link Write} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IWrite {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`Write.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    Write.validateCompatibility(parsed);
    return Write.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return Write.encode(this);
  }

  public static encode(record: IWrite): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    Write.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IWrite, view: BebopView): number {
    const before = view.length;
    const pos = view.reserveMessageLength();
    const start = view.length;
    if (record.suffix !== undefined) {
      view.writeByte(1);
      view.writeString(record.suffix);
    }
    if (record.prevTid !== undefined) {
      view.writeByte(2);
      view.writeBytes(record.prevTid);
    }
    if (record.value !== undefined) {
      view.writeByte(3);
      view.writeBytes(record.value);
    }
    if (record.deleted !== undefined) {
      view.writeByte(4);
      view.writeByte(Number(record.deleted));
    }
    view.writeByte(0);
    const end = view.length;
    view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IWrite {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return Write.readFrom(view);
  }

  public static readFrom(view: BebopView): IWrite {
    let message: IWrite = {};
    const length = view.readMessageLength();
    const end = view.index + length;
    while (true) {
      switch (view.readByte()) {
        case 0:
          return new Write(message);

        case 1:
          message.suffix = view.readString();
          break;

        case 2:
          message.prevTid = view.readBytes();
          break;

        case 3:
          message.value = view.readBytes();
          break;

        case 4:
          message.deleted = !!view.readByte();
          break;

        default:
          view.index = end;
          return new Write(message);
      }
    }
  }
}


export enum LockType {

  Unknown = 0,

  None = 1,

  Read = 2,

  Write = 3,

  Create = 4,
}


export interface ICollectionLocks extends BebopRecord {

  readonly collectionLock: LockType;

  readonly locks: Array<ILock>;
}

export class CollectionLocks implements ICollectionLocks {
  public readonly collectionLock: LockType;
  public readonly locks: Array<ILock>;

  constructor(record: ICollectionLocks) {
    this.collectionLock = record.collectionLock;
    this.locks = record.locks;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return CollectionLocks.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: ICollectionLocks): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    CollectionLocks.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link CollectionLocks}.
   */
  public static validateCompatibility(record: ICollectionLocks): void {
    BebopTypeGuard.ensureEnum(record.collectionLock, LockType);
    BebopTypeGuard.ensureArray(record.locks, Lock.validateCompatibility);
  }

  /**
   * Unsafely creates an instance of {@link CollectionLocks} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): ICollectionLocks {
      return new CollectionLocks(record);
  }

  /**
   * Creates a new {@link CollectionLocks} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): ICollectionLocks {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`CollectionLocks.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    CollectionLocks.validateCompatibility(parsed);
    return CollectionLocks.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return CollectionLocks.encode(this);
  }

  public static encode(record: ICollectionLocks): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    CollectionLocks.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: ICollectionLocks, view: BebopView): number {
    const before = view.length;
    view.writeUint32(record.collectionLock);
    {
      const length0 = record.locks.length;
      view.writeUint32(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        Lock.encodeInto(record.locks[i0], view)
      }
    }
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): ICollectionLocks {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return CollectionLocks.readFrom(view);
  }

  public static readFrom(view: BebopView): ICollectionLocks {
    let field0: LockType;
    field0 = view.readUint32() as LockType;
    let field1: Array<ILock>;
    {
      let length0 = view.readUint32();
      field1 = new Array<ILock>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: ILock;
        x0 = Lock.readFrom(view);
        field1[i0] = x0;
      }
    }
    let message: ICollectionLocks = {
      collectionLock: field0,
      locks: field1,
    };
    return new CollectionLocks(message);
  }
}


export interface ILock extends BebopRecord {

  readonly suffix: string;

  readonly lockType: LockType;
}

export class Lock implements ILock {
  public readonly suffix: string;
  public readonly lockType: LockType;

  constructor(record: ILock) {
    this.suffix = record.suffix;
    this.lockType = record.lockType;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return Lock.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: ILock): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    Lock.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link Lock}.
   */
  public static validateCompatibility(record: ILock): void {
    BebopTypeGuard.ensureString(record.suffix)
    BebopTypeGuard.ensureEnum(record.lockType, LockType);
  }

  /**
   * Unsafely creates an instance of {@link Lock} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): ILock {
      return new Lock(record);
  }

  /**
   * Creates a new {@link Lock} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): ILock {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`Lock.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    Lock.validateCompatibility(parsed);
    return Lock.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return Lock.encode(this);
  }

  public static encode(record: ILock): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    Lock.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: ILock, view: BebopView): number {
    const before = view.length;
    view.writeString(record.suffix);
    view.writeUint32(record.lockType);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): ILock {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return Lock.readFrom(view);
  }

  public static readFrom(view: BebopView): ILock {
    let field0: string;
    field0 = view.readString();
    let field1: LockType;
    field1 = view.readUint32() as LockType;
    let message: ILock = {
      suffix: field0,
      lockType: field1,
    };
    return new Lock(message);
  }
}

